{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "0ca11b2b-0e7d-3661-b188-bc856c1c1182",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&out, &dbits, sizeof(double))`, there is a potential risk if the size of `dbits` is larger than the size of `out`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif (sizeof(out) >= sizeof(dbits)) {\n    memcpy(&out, &dbits, sizeof(double));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this code, we first check if the size of `out` is larger or equal to the size of `dbits`. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9a1997b8-4d52-3676-97eb-5434f02f0098",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&out, &fbits, sizeof(float))`, there is a potential risk if the size of `fbits` is larger than `out`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(out) >= sizeof(fbits)) {\n    memcpy(&out, &fbits, sizeof(float));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `out` is larger or equal to the size of `fbits`. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c726c202-6be5-3b8a-9093-1e341a97e7df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&fbits, &value, sizeof(float))`, a vulnerability could occur if the size of `value` is larger than the size of `fbits`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is larger than the buffer, you should either increase the size of the buffer or reduce the size of the data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nif(sizeof(value) <= sizeof(fbits)) {\n    memcpy(&fbits, &value, sizeof(float));\n} else {\n    // Handle error\n}\n```\n\nIn this version, `memcpy` is only called if `value` is not larger than `fbits`. If `value` is larger, an error is handled instead.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa329ba1-de77-3e9d-869d-d99cfde6914e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file name or path is manipulated by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using file I/O operations provided by the C++ Standard Library, which are type-safe and exception-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `std::ofstream` class from the C++ Standard Library:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(\"conv_log_banner.csv\");\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library for file processing.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4a2f8ab4-bc46-33e7-b0b1-219157f069af",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to potential security risks if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of using `fopen`, consider using `fstream` in C++. Also, always validate and sanitize inputs, especially if they are used to construct file paths or other resources identifiers.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fstream` object from the C++ Standard Library. Here is an example of how to do it:\n\n```cpp\n#include <fstream>\n\nstd::ofstream outfile;\noutfile.open(\"conv_log.csv\", std::ios_base::app);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fedec4af-661a-3ff5-83cb-c9b67614d40b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states a risk of undefined behavior. The analysis determined that overlap is feasible based on data flow from the destination to the source, which can cause issues with functions like memcpy that do not support overlapping regions. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the operation does not ensure that the source and destination are distinct or non-null. These factors indicate a real risk of memory corruption or program crashes.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. You can add a runtime check to verify that the memory ranges are distinct:\n\n```cpp\nif ((char*)&dbits + sizeof(double) <= (char*)&value || (char*)&value + sizeof(double) <= (char*)&dbits) {\n    std::memcpy(&dbits, &value, sizeof(double));\n} else {\n    // Handle overlap case appropriately, e.g., use memmove or log an error\n}\n```\nThis check ensures that the memory regions do not overlap, preventing undefined behavior.\n\n## In Context Remediation 2\nIf there is a possibility of overlap between the source and destination, use `std::memmove` instead of `std::memcpy`, as `memmove` is designed to handle overlapping memory regions safely:\n\n```cpp\nstd::memmove(&dbits, &value, sizeof(double));\n```\nThis change ensures that the operation is safe even if the memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4dd105f7-7a53-30cf-b0a4-edc3f5ee9200",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `fopen` function is used, which can lead to potential security risks if the file path is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of using `fopen`, consider using `fstream` in C++. Also, always validate and sanitize inputs, especially if they are used to construct file paths or other resources identifiers.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fstream` object from the C++ Standard Library. Here is an example of how to do it:\n\n```cpp\n#include <fstream>\n\nstd::ofstream outfile;\noutfile.open(\"conv_log.csv\", std::ios_base::app);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5c079177-54e2-306d-baf3-308f6bfd5e61",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file name or path is manipulated by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using file I/O operations provided by the C++ Standard Library, which are type-safe and exception-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `std::ofstream` class from the C++ Standard Library:\n\n```cpp\n#include <fstream>\n\nstd::ofstream file(\"conv_log_banner.csv\");\nif (!file) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`: This is a standard C++ library for file processing.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d207608c-0491-3d44-9b41-6409f8bcac4c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies memory from one buffer to another using a function that does not handle overlapping regions safely. Dataflow analysis indicates that the source and destination may refer to overlapping memory, which can cause unpredictable results. Additionally, there are no checks to ensure that either the source or destination pointers are non-null, increasing the risk of null pointer dereference. No explicit bounds or capacity checks are present, and the number of bytes copied is not directly tied to the size of the destination buffer. These factors all contribute to a high-confidence, actionable issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add a runtime check to verify that the memory ranges are either completely separate or use a function that safely handles overlapping regions if overlap is possible.\n\n```c\nif ((t_dest->mem + bytes <= t_src->mem) || (t_src->mem + bytes <= t_dest->mem)) {\n    memcpy(t_dest->mem, t_src->mem, bytes);\n} else {\n    // Handle overlap safely, e.g., use memmove\n    memmove(t_dest->mem, t_src->mem, bytes);\n}\n```\n\n\n## In Context Remediation 2\nReplace the memory copy function with one that is designed to handle overlapping memory regions, such as `memmove`. This ensures that even if the source and destination regions overlap, the operation will be performed safely.\n\n```c\nmemmove(t_dest->mem, t_src->mem, bytes);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a00a9da8-f324-3979-bb63-7c6703bb89ae",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that is considered unsafe due to its potential for causing buffer overflows, format string vulnerabilities, or other types of security issues. In this case, the function `atoi()` is used, which is a standard library function in C++ that converts a string to an integer. The `atoi()` function does not perform any error checking, so if the input string is not a valid integer, the behavior of the function is undefined, which can lead to unexpected results and potential security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `atoi()`, such as `strtol()` or `sscanf()`, which provide error checking. Additionally, always validate and sanitize input data before processing it to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with a safer alternative. Here is an example of how to do this with `strtol()`:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nconst char* env_value = getenv(\"ENV_VAR\");\nchar* endptr;\nlong int_value = strtol(env_value, &endptr, 10);\n\nif (endptr == env_value || *endptr != '\\0' || errno == ERANGE) {\n    // handle the error, the input was not a valid integer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()`\n- `<cerrno>`: for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3ea78b17-2d4a-32ee-94ec-846c1df4e3ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or that are susceptible to integer overflows, underflows, or other types of vulnerabilities. Instead, use safer alternatives provided by the C++ Standard Library. \n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `std::stoi()`, which throws an exception if the converted value would fall out of the range of the result type or if the underlying function reports an error.\n\n```cpp\n#include <string>\n\ntry {\n    int val = std::stoi(val_string);\n} catch (const std::out_of_range& e) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9ce10244-13e3-3474-bfe6-43c66b6eddc7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function atof() is used, which converts a string to a double. This function does not perform any error checking, so if the string cannot be converted into a double, it will return zero, which can lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using C standard library functions that do not perform bounds checking or error checking. Instead, use safer alternatives that are provided by the C++ standard library. In this case, you can use std::stod() function which throws an exception if the conversion cannot be performed.\n\n## Source Code Fix Recommendation\n\nReplace the atof() function with std::stod() function. Here is the fixed code:\n\n```cpp\ntry {\n    double val_double = std::stod(val);\n} catch (const std::invalid_argument& ia) {\n    // Handle the exception\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <string>\n```\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8fed20a1-0333-3bc9-ba0b-0b3e003fae1d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atoi(var)` is used, which can lead to integer overflow.\n\nThe `atoi()` function converts a string to an integer. It does not check for overflow or underflow, and it does not signal any error conditions.\n\n## Mitigation Advice\n\nAvoid using the `atoi()` function. Instead, use functions that can handle errors more gracefully. In C++, you can use the `std::stoi()` function, which throws an exception if the conversion cannot be performed or if the converted value is out of the range of representable values by an int.\n\n## Source Code Fix Recommendation\n\nReplace `atoi(var)` with `std::stoi(var)`. Here is an example:\n\n```cpp\n#include <string>\n\nint main() {\n    std::string var = \"123\";\n    int num = std::stoi(var);\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<string>` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "0ca11b2b-0e7d-3661-b188-bc856c1c1182",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/half.hpp"
                },
                "region": {
                  "startLine": 1274,
                  "startColumn": 8,
                  "endLine": 1274,
                  "endColumn": 43,
                  "charOffset": 75267,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(&out, &dbits, sizeof(double)",
                    "rendered": {
                      "text": "memcpy(&out, &dbits, sizeof(double)",
                      "markdown": "`memcpy(&out, &dbits, sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/executable/half.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75267,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&out, <size of &out>,  &dbits,  sizeof(double)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a1997b8-4d52-3676-97eb-5434f02f0098",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/half.hpp"
                },
                "region": {
                  "startLine": 1251,
                  "startColumn": 8,
                  "endLine": 1251,
                  "endColumn": 42,
                  "charOffset": 74481,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(&out, &fbits, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(&out, &fbits, sizeof(float)",
                      "markdown": "`memcpy(&out, &fbits, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/executable/half.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74481,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&out, <size of &out>,  &fbits,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c726c202-6be5-3b8a-9093-1e341a97e7df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/half.hpp"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 44,
                  "charOffset": 36365,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&fbits, &value, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(&fbits, &value, sizeof(float)",
                      "markdown": "`memcpy(&fbits, &value, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/executable/half.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36365,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&fbits, <size of &fbits>,  &value,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa329ba1-de77-3e9d-869d-d99cfde6914e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend/op_convolution_cudnn.cc"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 22,
                  "endLine": 44,
                  "endColumn": 27,
                  "charOffset": 1318,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4a2f8ab4-bc46-33e7-b0b1-219157f069af",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend/op_convolution_cudnn.cc"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 9,
                  "endLine": 41,
                  "endColumn": 14,
                  "charOffset": 1225,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fedec4af-661a-3ff5-83cb-c9b67614d40b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/half.hpp"
                },
                "region": {
                  "startLine": 1002,
                  "startColumn": 8,
                  "endLine": 1002,
                  "endColumn": 45,
                  "charOffset": 43521,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(&dbits, &value, sizeof(double)",
                    "rendered": {
                      "text": "memcpy(&dbits, &value, sizeof(double)",
                      "markdown": "`memcpy(&dbits, &value, sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/executable/half.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43521,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dbits, <size of &dbits>,  &value,  sizeof(double)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4dd105f7-7a53-30cf-b0a4-edc3f5ee9200",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend/op_convolution_miopen.cc"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 9,
                  "endLine": 59,
                  "endColumn": 14,
                  "charOffset": 1898,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5c079177-54e2-306d-baf3-308f6bfd5e61",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend/op_convolution_miopen.cc"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 22,
                  "endLine": 62,
                  "endColumn": 27,
                  "charOffset": 1991,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d207608c-0491-3d44-9b41-6409f8bcac4c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend/backend.cc"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 4,
                  "endLine": 90,
                  "endColumn": 42,
                  "charOffset": 2608,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(t_dest->mem, t_src->mem, bytes)",
                    "rendered": {
                      "text": "memcpy(t_dest->mem, t_src->mem, bytes)",
                      "markdown": "`memcpy(t_dest->mem, t_src->mem, bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend/backend.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2608,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(t_dest->mem, <size of t_dest->mem>,  t_src->mem,  bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a00a9da8-f324-3979-bb63-7c6703bb89ae",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/op_driver.cc"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 11,
                  "endLine": 183,
                  "endColumn": 15,
                  "charOffset": 4504,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3ea78b17-2d4a-32ee-94ec-846c1df4e3ac",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/op_driver.cc"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 19,
                  "endLine": 272,
                  "endColumn": 23,
                  "charOffset": 7590,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9ce10244-13e3-3474-bfe6-43c66b6eddc7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/op_driver.cc"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 26,
                  "endLine": 276,
                  "endColumn": 30,
                  "charOffset": 7736,
                  "charLength": 4,
                  "snippet": {
                    "text": "atof",
                    "rendered": {
                      "text": "atof",
                      "markdown": "`atof`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8fed20a1-0333-3bc9-ba0b-0b3e003fae1d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/executable/op_driver.cc"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 20,
                  "endLine": 124,
                  "endColumn": 24,
                  "charOffset": 2939,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}